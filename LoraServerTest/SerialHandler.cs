using System;
using System.IO.Ports;
using System.Text;
using System.Threading;
using System.Collections;
using System.Collections.Generic;


/*
 * Created: 10/09/2019 9:20:29 PM
 * Author : Vaughn Nugent
 * 
 * Working test code for serial handler class to manage the serial coms between the device and program
 * A queue is used to store incoming serial packets when needed
 * Most if not all exceptions in this class are handled and pushed to a Exception stack passed from
 * parent class. 
 */



namespace RadioManager
{
    class SerialHandler
    {
                
        private Queue<Byte[]> received_queue;
        
        private SerialPort CurrentPort;

        private int max_queue_size;

        private Stack<Exception> running_exceptions;

        public string Name = "";

        public bool Exists = false;
                
        public SerialHandler(Stack<Exception> exp_stack, Int32 max_queue_size)
        {
            CurrentPort = null;
            received_queue = new Queue<byte[]>();
            this.max_queue_size = max_queue_size;
            this.running_exceptions = exp_stack;           
        }
        public SerialHandler(Stack<Exception> exp_stack, string port_name, Int32 baud_rate, Int32 max_queue_size) // Make a port and start it....
        {
            this.running_exceptions = exp_stack;
            Start(port_name, baud_rate);
            received_queue = new Queue<byte[]>();
            this.max_queue_size = max_queue_size;
        }


        public static string[] GetPorts() // Returns an array of all the availabe COM ports generated by the drivers on your pc
        {
            string[] ports = SerialPort.GetPortNames();           
            return ports;
        }


        public Boolean Start(string port_name, Int32 baud_rate) 
        {
            try 
            {

                if (this.CurrentPort != null && this.CurrentPort.IsOpen) // Closing serial port if there is already one open
                    this.CurrentPort.Close();

                this.CurrentPort = new SerialPort(port_name, baud_rate);  // Creating serial port object with baud rate and port num, there are many other options that will be necessary later when we want to do ecc
                
                this.CurrentPort.DataReceived +=
                    new SerialDataReceivedEventHandler(DataEventHandler); // Attaches an event handler that calls the handler function below only when serial data is recieved by the port
                                
                this.CurrentPort.Open();
                this.Name = port_name;
                this.Exists = true;
                return true; 
                
            }
            catch(Exception exp)
            {
                this.running_exceptions.Push(exp);
                return false; // Couldn't open the port with the options configured... 
            }

        }


       
        private void DataEventHandler(object sender, SerialDataReceivedEventArgs e) // Event handler calls this function 
        {
            Thread.Sleep(70);
            int size = this.CurrentPort.BytesToRead; // Number of bytes currently sitting in the rx buff
            byte[] recieved_data = new byte[size]; // so we can create a byte array (buffer) the same size to store the data
            int chars_read = this.CurrentPort.Read(recieved_data, 0, size); // Writes current bytes to the recieved byte array (buffer) 
            
            if (chars_read == 0)
                return ; // if there wasnt any data loaded to the buffer return
            if (this.received_queue.Count >= this.max_queue_size)
                return ;

            try
            {
                this.received_queue.Enqueue(recieved_data);
            }
            catch (Exception exp)
            {
                this.running_exceptions.Push(exp);
            }
           return;
                      
        }

        
        public void WriteSerial(byte[] data)
        {
            try
            {
                this.CurrentPort.Write(data, 0, data.Length); 
                                                              
            }
            catch(Exception exp)
            {
                this.running_exceptions.Push(exp);
            }
        }


        public bool Assert(byte[] assert, byte[] response, int timeout)
        {
           
            WriteSerial(assert);

            int count = 0;
            while(count<10)
            {
                if(this.received_queue.Contains(response))
                {
                    return Remove(response);
                }
                //Check 10 times per timeout session 
                Thread.Sleep(timeout / 10);
                count++;
            }
            return false;
        }

        public bool AssertForResponse(byte[] assert, int timeout)
        {
            int current_size = this.received_queue.Count;

            WriteSerial(assert);          

            int count = 0;
            while (count < 10)
            {
                if (this.received_queue.Count > current_size)
                {
                    Retrieve();                  
                    return true;
                }
                //Check 10 times per timeout session 
                Thread.Sleep(timeout / 10);
                count++;                
            }
            return false;
        }


        /***************************************/
        /*              RX Queue               */
        /***************************************/

        public int RxSize()
        {
            return this.received_queue.Count;
        }


        public bool Remove(byte[] data)
        {
            try
            {
                ICollection<byte[]> coll = this.received_queue.ToArray();

                if (coll.Contains(data))
                {
                    if (coll.Remove(data))
                    {
                        Queue<byte[]> transfer = new Queue<byte[]>(coll);
                        this.received_queue = transfer;
                        return true;
                    }
                }
            }
            catch(Exception exp)
            {
                this.running_exceptions.Push(exp);
            }
            return false;
        }

       public byte[] Retrieve()
        {
            return this.received_queue.Dequeue();
        }


        //Just close the serial port and dispose of it so were good programmers
        public Boolean ClosePort()
        {
            if (this.CurrentPort == null)
            {
                return true;
            }
            try
            {
                this.CurrentPort.Close();
            }
            catch(Exception exp)
            {
                this.running_exceptions.Push(exp);
                return false;
            }

            if (!this.CurrentPort.IsOpen)
            {
                this.CurrentPort.Dispose(); // Dispose port after closed
                this.Exists = false;        // Port is closed, remove exists 
                this.received_queue.Clear();  // Clear rx queue
                return true; // the port is closed
            }
            return false;
        }

    }
}
