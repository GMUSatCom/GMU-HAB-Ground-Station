using System;
using System.IO.Ports;
using System.Text;
using System.Threading;

namespace Arduino_USB_Console
{
    class SerialHandler
    {

        /*
         * Vaughn Nugent Sept 28, 2019
         * Demo program for semi-complicated serial transmission between arduino and the System Consol Host
         * 
         * This program is not meant to be complete and I am not that great of a programmer, this is meant to be 
         * a demo for the GMU High Altitude Balloon Radio team to understand low level serial comunication over UART between a 
         * System Console Host (commands) and a MCU, more specifically an arduino mega and uno. 
         * 
         */


        SerialPort CurrentPort;

        //Blank constructor sets the port to null so the rest of the program can handle the null and know to configure it later
        public SerialHandler()
        {
            CurrentPort = null;
        }
        public SerialHandler(Int32 port_num, Int32 baud_rate) // Make a port and start it....
        {
            Start(port_num, baud_rate);
        }


        public static string[] GetPorts() // Returns an array of all the availabe COM ports generated by the drivers on your pc
        {
            string[] ports = SerialPort.GetPortNames();
            return ports;
        }


        public Boolean Start(Int32 port_num, Int32 baud_rate) // In hindsight, I probablt should have just stuck to the port name, but this seemed cleaner for the rest of the program
        {
            string port_name = GetPorts()[port_num]; // just gets the port by name because the port num is just the index of the array (this is already normalized in the main app)


            if (this.CurrentPort != null && this.CurrentPort.IsOpen) // Closing serial port if there is already one open
                this.CurrentPort.Close();

            this.CurrentPort = new SerialPort(port_name, baud_rate);      // Creating serial port object with baud rate and port num, there are many other options that will be necessary later when we want to do ecc

            this.CurrentPort.DataReceived +=
                new SerialDataReceivedEventHandler(DataEventHandler); // Attaches an event handler that calls the handler function below only when serial data is recieved by the port

            try
            {
                this.CurrentPort.Open(); // Opens the serial port
                return true; // Ight we good. 
            }
            catch
            {
                return false; // Yeah nah, couldn't open the port with the options configured... 
            }

        }


        /*
         * Special sauce here!!!
         * 
         * So this event is attached to the serial port object above. This event is raised the INSANT the serial buffer recieves data, which is 
         * complicated to work around, but it is very important. 
         * 
         * This is the best way to handle comunication priority.
         * If this method responds to the bytes in the ports recieve buffer too quickly the reponse might be funky
         * 
         * You will notice that I have a long thread sleep time of 400ms to allow for the RX buffer to continue to recive bytes so to have larger output buffers 
         * 
         * Basically stuff looks stupid on the console if you spit the data out faster than the arduino can fill the pc's recive buffer all because of how tiny the 
         * transmit buffer is on the arduino boards. So its just best to wait for the arduino to send more data and the pc can print it to the screen all at once.
         * 
         */
        private void DataEventHandler(object sender, SerialDataReceivedEventArgs e) // Event handler calls this function 
        {
            Thread.Sleep(400);
            int size = this.CurrentPort.BytesToRead; // Number of bytes currently sitting in the rx buff
            byte[] recieved_data = new byte[size]; // so we can create a byte array (buffer) the same size to store the data
            int chars_read = this.CurrentPort.Read(recieved_data, 0, size); // Writes current bytes to the recieved byte array (buffer) 
            if (chars_read == 0)
                return; // if there wasnt any data loaded to the buffer return
            
            Console.WriteLine(Encoding.UTF8.GetString(recieved_data, 0,size) + "\n"); // attempt to interpret the data and print it to the screen deconding with UTF8
        }

        
        public void WriteSerial(byte[] buff)
        {
            this.CurrentPort.Write(buff, 0, buff.Length); // write one byte after another from the input buffer
            //We can build packets this way in the future! one byte arary can contian all the data we need including mcu commands to be passed to the radio control methods in firmware

        }

        //Just close the serial port and dispose of it so were good programmers
        public Boolean ClosePort()
        {
            if (this.CurrentPort == null)
            {
                return true;
            }
            try
            {
                this.CurrentPort.Close();
            }
            catch
            {
                return false;
            }

            if (!this.CurrentPort.IsOpen)
            {
                this.CurrentPort.Dispose();
                return true; // the port is closed
            }
            return false;
        }

    }
}
